# 3186. [施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/)

## 📋 题目描述

一个魔法师有许多不同的咒语。给你一个数组 `power`，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。

已知魔法师使用伤害值为 `power[i]` 的咒语时，他们就**不能**使用伤害为 `power[i] - 2`、`power[i] - 1`、`power[i] + 1` 或者 `power[i] + 2` 的咒语。

每个咒语最多只能被使用**一次**。

请你返回这个魔法师可以达到的伤害值之和的**最大值**。

**示例 1：**
```
输入：power = [1,1,3,4]
输出：6
解释：
可以使用咒语 0, 1, 3，伤害值分别为 1, 1, 4，总伤害值为 1 + 1 + 4 = 6 。
```

**示例 2：**
```
输入：power = [7,1,6,6]
输出：13
解释：
可以使用咒语 1, 2, 3，伤害值分别为 1, 6, 6，总伤害值为 1 + 6 + 6 = 13 。
```

**提示：**
- `1 <= power.length <= 10^5`
- `1 <= power[i] <= 10^9`

---

## 💡 解题思路

这道题是 [740. 删除并获得点数](./740.md) 的进阶版，核心是**值域上的打家劫舍**。

### 关键观察

1. **选择的完整性**：
   - 如果选择伤害值为 `x` 的咒语，应该选择**所有**伤害值为 `x` 的咒语
   - 因为它们的约束相同，多选不增加限制

2. **约束条件更严格**：
   - 740 题：选 `x` 不能选 `x-1` 和 `x+1`（2个相邻值）
   - 本题：选 `x` 不能选 `x-2`, `x-1`, `x+1`, `x+2`（4个相邻值）

3. **值域不连续**：
   - `power[i]` 范围很大（最大 10^9），但不同值的个数最多 10^5
   - 不能直接用数组存储，需要用哈希表

### 思路分析

**第一步：统计和排序**

1. 统计每个伤害值出现的次数：`cnt[x] = 出现次数`
2. 提取所有不同的伤害值到数组 `a`，并排序

**第二步：打家劫舍（值域上）**

**状态定义：**
- `f(i)` 表示考虑前 `i` 个不同的伤害值，能获得的最大总伤害

**状态转移：**

对于第 `i` 个伤害值 `a[i].first`（出现 `a[i].second` 次）：

1. **不选**：`f(i) = f(i-1)`
2. **选**：找到最大的 `j` 使得 `a[j].first < a[i].first - 2`
   - `f(i) = f(j) + a[i].first × a[i].second`

取两者的最大值。

**为什么要找 `a[j].first < a[i].first - 2`？**
- 选 `a[i].first` 后，不能选 `a[i].first - 2` 及更大的值（直到 `a[i].first + 2`）
- 所以只能选 `a[i].first - 3` 及更小的值
- 即 `a[j].first < a[i].first - 2`

### 图解示例

对于 `power = [1,1,3,4]`：

```
统计：
  cnt[1] = 2
  cnt[3] = 1
  cnt[4] = 1

排序后：
  a = [(1, 2), (3, 1), (4, 1)]
       ↑        ↑       ↑
      选择     跳过    跳过

决策过程：
i=0: a[0]=(1,2)
  选：1×2 = 2

i=1: a[1]=(3,1)
  选 3 会禁用 1,2,4,5
  但 1 已经选了！矛盾？
  不对，我们需要重新理解...

正确理解：
i=0: 考虑值 1，选所有的 1，得 2
i=1: 考虑值 3
  - 选 3：不能选 1,2,4,5
    → 必须放弃 i=0 的选择
    → 总伤害 = 0 + 3 = 3
  - 不选 3：保留 i=0
    → 总伤害 = 2
  → 选不选 3 都行，但选 3 更优

i=2: 考虑值 4
  - 选 4：不能选 2,3,5,6
    → 可以选 1！
    → 总伤害 = 2 + 4 = 6 ✓
  - 不选 4：
    → 总伤害 = 3（来自选3）

答案：6
```

---

## 💻 代码实现

### 方法一：记忆化搜索

```cpp
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        // 统计每个伤害值的出现次数
        unordered_map<int, int> cnt;
        for (int x : power) {
            cnt[x]++;
        }

        // 提取并排序
        vector<pair<int, int>> a(cnt.begin(), cnt.end());
        ranges::sort(a);

        int n = a.size();
        vector<long long> memo(n, -1);

        // dfs(i) 表示考虑前 i+1 个不同伤害值的最大总伤害
        auto dfs = [&](auto&& dfs, int i) -> long long {
            if (i < 0) return 0;

            // 记忆化
            if (memo[i] != -1) return memo[i];

            auto& [x, c] = a[i];

            // 找到最大的 j 使得 a[j].first < x - 2
            int j = i;
            while (j > 0 && a[j - 1].first >= x - 2) {
                j--;
            }

            // 不选 vs 选
            return memo[i] = max(dfs(dfs, i - 1),
                                 dfs(dfs, j - 1) + (long long)x * c);
        };

        return dfs(dfs, n - 1);
    }
};
```

**代码解析：**
1. 用哈希表统计每个值的出现次数
2. 转换为 `vector<pair<int, int>>` 并排序
3. `dfs(i)` 考虑前 `i+1` 个不同的伤害值
4. 找到可以转移的位置 `j`

**复杂度分析：**
- 时间复杂度：O(n log n + n²)，排序 + 每次找 j
- 空间复杂度：O(n)

---

### 方法二：动态规划（递推）

```cpp
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        // 统计每个伤害值的出现次数
        unordered_map<int, int> cnt;
        for (int x : power) {
            cnt[x]++;
        }

        // 提取并排序
        vector<pair<int, int>> a(cnt.begin(), cnt.end());
        ranges::sort(a);

        int n = a.size();

        // f[i+1] 表示考虑前 i+1 个不同伤害值的最大总伤害
        // f[0] = 0（不考虑任何值）
        vector<long long> f(n + 1, 0);

        for (int i = 0, j = 0; i < n; i++) {
            auto& [x, c] = a[i];

            // 移动 j 到第一个可以转移的位置
            // 即找到最大的 j 使得 a[j].first < x - 2
            while (j < i && a[j].first < x - 2) {
                j++;
            }

            // 状态转移
            f[i + 1] = max(f[i],                          // 不选 a[i]
                           f[j] + (long long)x * c);      // 选 a[i]
        }

        return f[n];
    }
};
```

**为什么是 `f[i+1]` 而不是 `f[i]`？**

为了处理 `i = -1` 的边界情况（不考虑任何值），我们在 `f` 数组左边插入一个状态 `f[0] = 0`：
- `f[i+1]` 对应考虑前 `i+1` 个值（即 `a[0]` 到 `a[i]`）
- `f[0]` 对应不考虑任何值

**为什么要用双指针 `j`？**

由于 `a` 是排序的，随着 `i` 增大，可以转移的位置 `j` 也单调增加，所以用双指针优化。

**复杂度分析：**
- 时间复杂度：O(n log n + n)，排序 + 双指针遍历
- 空间复杂度：O(n)

---

## 🔍 注意事项与技巧

### 易错点

1. **理解约束范围**
   - 选 `x` 禁用 `[x-2, x+2]` 共 5 个值
   - 不是只禁用 `x-1` 和 `x+1`

2. **找转移位置**
   - 要找的是 `a[j].first < x - 2`，不是 `<= x - 3`
   - 等价但前者更直观

3. **数据类型**
   - 答案可能很大，用 `long long`
   - `x * c` 也要转换为 `long long`

4. **数组偏移**
   - 使用 `f[i+1]` 时要注意下标对应关系
   - `f[i+1]` 对应 `a[i]`

### 解题技巧

1. **识别打家劫舍变形**
   - 看到"选某个值会禁用相邻值"
   - 立即联想打家劫舍模型

2. **值域上的DP**
   - 当约束是基于值而不是位置时
   - 先统计、排序、再DP

3. **双指针优化**
   - 利用排序的单调性
   - 避免每次都暴力找 `j`

### 与 740 题的对比

| 特征 | 740. 删除并获得点数 | 3186. 施咒的最大总伤害 |
|------|------------------|---------------------|
| 禁用范围 | `[x-1, x+1]` | `[x-2, x+2]` |
| 值域 | `[1, 10^4]` | `[1, 10^9]` |
| 存储方式 | 数组 | 哈希表 + 排序 |
| 转移 | `f[i] = max(f[i-1], f[i-2] + sum[i])` | 需要找 `j` |

---

## 📊 状态转移示例

对于 `power = [7,1,6,6]`：

```
统计：
  cnt[1] = 1
  cnt[6] = 2
  cnt[7] = 1

排序后：
  a = [(1,1), (6,2), (7,1)]

DP 过程：
i=0, a[0]=(1,1):
  j=0 (没有 < 1-2=-1 的)
  f[1] = max(f[0], f[0] + 1×1) = max(0, 1) = 1

i=1, a[1]=(6,2):
  j=0 (需要 < 6-2=4, 只有 a[0]=1 满足)
  但 j 要移动到第一个 >= 4 的位置，所以 j=1
  实际上这里 j 应该停在 a[j] >= 4 的第一个位置

  让我重新理解代码...
  while (j < i && a[j].first < x - 2)
  这是移动 j 直到 a[j].first >= x - 2

  对于 x=6: 找 a[j].first >= 4
    j 从 0 开始，a[0]=1 < 4，j++
    j=1, a[1]=6 >= 4，停止
  所以 f[2] = max(f[1], f[1] + 6×2) = max(1, 1+12) = 13

  等等，这里 f[j] 应该是 f[1] 吗？
  不对，应该是 f[0]！

  重新看代码：while 之后，j 指向第一个 >= x-2 的位置
  我们要的是 < x-2 的最后一个位置的 f 值
  所以应该用 f[j]，其中 j 指向第一个 >= x-2 的位置

  实际上代码逻辑：
    - j 移动到第一个 a[j].first >= x-2 的位置
    - 用 f[j]，表示可以选 a[0]..a[j-1]

  对于 x=6:
    j 最终指向 a[1]=6（第一个 >= 4）
    f[2] = max(f[1], f[1] + 12)

  这里有问题，让我重新理解...

实际上正确的理解：
  while 循环让 j 移动到第一个 "不能选" 的位置
  f[j] 表示选择 a[0]..a[j-1] 的最大值

对于 power = [7,1,6,6]:
  a = [(1,1), (6,2), (7,1)]

  i=0: f[1] = max(0, 0+1) = 1

  i=1, x=6:
    找第一个 >= 4 的，是 a[1]=6
    所以 j=1
    f[2] = max(f[1]=1, f[1]=1+12) = 13

  等等，选6应该禁用4,5,7,8
  所以不能选7

  i=2, x=7:
    找第一个 >= 5 的，是 a[1]=6
    所以 j=1
    f[3] = max(f[2]=13, f[1]=1+7) = max(13, 8) = 13

答案：13 ✓
```

---

## 🔗 相关题目

- [198. 打家劫舍](./198.md)（基础模型）
- [740. 删除并获得点数](./740.md)（值域DP入门）
- [213. 打家劫舍 II](./213.md)（环形问题）

---

## 💪 总结

这道题的核心思想：
1. **值域上的打家劫舍**：在不同伤害值上做选择
2. **统计 + 排序**：将问题转化为有序的决策过程
3. **找转移位置**：利用排序性质，用双指针优化

**关键点：**
- 理解"选 x 禁用 [x-2, x+2]"的约束
- 统计相同值的个数
- 找到正确的转移位置 j

**难度提升：**
- 相比 740 题，禁用范围更大
- 值域范围大，需要用哈希表
- 转移时需要找 j，不是简单的 i-1 或 i-2

掌握这道题，可以理解**如何处理更复杂约束的值域DP问题**。
