# 198. [打家劫舍](https://leetcode.cn/problems/house-robber/)

## 📋 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是**相邻的房屋装有相互连通的防盗系统**，如果**两间相邻的房屋**在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。

**示例 1：**
```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**
```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

---

## 💡 解题思路

这是一道经典的**动态规划**问题，核心在于处理"不能选相邻元素"的约束条件。

### 思路分析

对于第 `i` 个房屋，我们有两种选择：

1. **偷第 `i` 个房屋**：
   - 那么不能偷第 `i-1` 个房屋
   - 最大金额 = `前 i-2 个房屋的最大金额 + nums[i]`

2. **不偷第 `i` 个房屋**：
   - 最大金额 = `前 i-1 个房屋的最大金额`

取两者的最大值即可。

**状态定义：**
- `f(i)` 表示从前 `i` 个房屋中能偷到的最大金额

**状态转移方程：**
$$f(i) = \max(f(i-1), f(i-2) + \text{nums}[i])$$

**边界条件：**
- `f(0) = 0`（没有房屋，金额为 0）
- `f(1) = nums[0]`（只有一个房屋，偷它）

### 为什么这样是对的？

关键在于理解 `f(i)` 的定义：它表示**前 `i` 个房屋能偷到的最大金额**，而不是"必须偷第 `i` 个房屋"。

这样定义的好处是：
- 如果偷第 `i` 个，就取 `f(i-2) + nums[i]`
- 如果不偷第 `i` 个，就取 `f(i-1)`
- 两者取最大值，保证了答案的正确性

---

## 💻 代码实现

### 方法一：动态规划（数组）

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        // dp[i+2] 表示偷前 i 个房屋的最大金额
        // 下标从 2 开始，避免处理负数索引
        vector<int> dp(n + 2, 0);

        for (int i = 0; i < n; i++) {
            // dp[i+2] = max(不偷第i个, 偷第i个)
            //         = max(dp[i+1], dp[i] + nums[i])
            dp[i + 2] = max(dp[i + 1], dp[i] + nums[i]);
        }

        return dp[n + 1];
    }
};
```

**为什么用 `dp[i+2]`？**
- 为了避免处理 `i-1` 和 `i-2` 的负数索引
- `dp[i+2]` 对应偷前 `i` 个房屋的最大金额
- `dp[0]` 和 `dp[1]` 作为初始状态，都是 0

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

---

### 方法二：动态规划（空间优化）⭐ 推荐

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        // dp0 = f(i-2), dp1 = f(i-1)
        int dp0 = 0, dp1 = 0;

        for (int i = 0; i < n; i++) {
            // 计算 f(i)
            int newDp = max(dp1, dp0 + nums[i]);

            // 滚动更新
            dp0 = dp1;
            dp1 = newDp;
        }

        return dp1;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(1) ✅

---

### 方法三：记忆化搜索（自顶向下）

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, -1);
        return dfs(nums, n - 1, memo);
    }

private:
    // dfs(i) 表示从前 i+1 个房屋中能偷到的最大金额
    int dfs(vector<int>& nums, int i, vector<int>& memo) {
        // 边界条件
        if (i < 0) return 0;
        if (i == 0) return nums[0];

        // 记忆化
        if (memo[i] != -1) return memo[i];

        // 状态转移：选或不选第 i 个房屋
        memo[i] = max(dfs(nums, i - 1, memo),
                      dfs(nums, i - 2, memo) + nums[i]);

        return memo[i];
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

---

## 🔍 注意事项与技巧

### 易错点

1. **下标偏移问题**
   - 使用 `dp[i+2]` 时，要注意对应关系
   - `dp[i+2]` 表示前 `i` 个房屋，不是前 `i+2` 个

2. **边界条件**
   - 空数组：返回 0
   - 只有一个房屋：返回 `nums[0]`

3. **状态定义的理解**
   - `f(i)` 是"前 i 个房屋的最大金额"
   - 不是"必须偷第 i 个房屋的最大金额"

### 解题技巧

1. **识别问题模式**
   - 看到"不能选相邻元素求最值"，考虑打家劫舍模型
   - 关键词：相邻、最大值/最小值、选或不选

2. **空间优化技巧**
   - 当 `dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]` 时
   - 可以用两个变量滚动更新，优化空间到 O(1)

3. **调试技巧**
   - 手算小样例：`[2,7,9,3,1]`
   - 画出 dp 数组的变化过程

### 状态转移的直观理解

```
房屋:  [2,  7,  9,  3,  1]
索引:   0   1   2   3   4

dp 数组变化过程：
i=0: dp = [0, 0, 2]        偷第0个，金额2
i=1: dp = [0, 2, 7]        偷第1个，金额7
i=2: dp = [2, 7, 11]       偷第0+2个，金额2+9=11
i=3: dp = [7, 11, 11]      不偷第3个，保持11
i=4: dp = [11, 11, 12]     偷第0+2+4个，金额2+9+1=12
```

---

## 📊 相关题目

- [213. 打家劫舍 II](./213.md)（环形房屋）
- [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)（树形 DP）
- [740. 删除并获得点数](./740.md)（变形题）
- [70. 爬楼梯](./70_climb_the_stairs.md)（基础 DP）

---

## 💪 刷题心得

打家劫舍是 DP 入门的经典题目，掌握它可以解决一类"不能选相邻元素"的问题。

**进阶路线：**
1. 先做 70. 爬楼梯（理解基础 DP）
2. 再做 198. 打家劫舍（加入选择约束）
3. 然后做 213. 打家劫舍 II（环形变种）
4. 最后做 337. 打家劫舍 III（树形 DP）
