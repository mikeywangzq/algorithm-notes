# 70. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

## 📋 题目描述

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：**
- `1 <= n <= 45`

---

## 💡 解题思路

这是一道经典的动态规划入门题，本质上是**斐波那契数列**的变形。

### 思路分析

要到达第 `n` 阶，可以从两个位置到达：
1. 从第 `n-1` 阶走 1 步
2. 从第 `n-2` 阶走 2 步

因此，到达第 `n` 阶的方法数 = 到达第 `n-1` 阶的方法数 + 到达第 `n-2` 阶的方法数

**状态定义：**
- `f(n)` 表示爬到第 `n` 阶的方法数

**状态转移方程：**
$$f(n) = f(n-1) + f(n-2)$$

**边界条件：**
- `f(0) = 1`（站在地面，1 种方法）
- `f(1) = 1`（爬 1 阶，1 种方法）

### 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|----------|----------|------|
| 递归（未优化） | O(2^n) | O(n) | 指数级时间，不可行 |
| 记忆化搜索 | O(n) | O(n) | 自顶向下 DP |
| 动态规划（数组） | O(n) | O(n) | 自底向上 DP |
| 动态规划（空间优化） | O(n) | O(1) | **最优解** |

---

## 💻 代码实现

### 方法一：记忆化搜索

```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> memo(n + 1, -1);
        return dfs(n, memo);
    }

private:
    int dfs(int n, vector<int>& memo) {
        // 边界条件
        if (n == 0 || n == 1) {
            return 1;
        }

        // 如果已经计算过，直接返回
        if (memo[n] != -1) {
            return memo[n];
        }

        // 状态转移：f(n) = f(n-1) + f(n-2)
        memo[n] = dfs(n - 1, memo) + dfs(n - 2, memo);
        return memo[n];
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)，每个状态只计算一次
- 空间复杂度：O(n)，递归栈 + memo 数组

---

### 方法二：动态规划（数组）

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // 特殊情况处理
        if (n <= 1) return 1;

        // dp[i] 表示爬到第 i 阶的方法数
        vector<int> dp(n + 1);
        dp[0] = 1;  // 初始状态
        dp[1] = 1;  // 初始状态

        // 自底向上计算
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

---

### 方法三：动态规划（空间优化）⭐ 推荐

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // 特殊情况
        if (n <= 1) return 1;

        // 只需要保存前两个状态
        int dp0 = 1;  // f(i-2)
        int dp1 = 1;  // f(i-1)
        int dp2;      // f(i)

        // 滚动更新
        for (int i = 2; i <= n; i++) {
            dp2 = dp1 + dp0;  // f(i) = f(i-1) + f(i-2)
            dp0 = dp1;        // 更新 f(i-2)
            dp1 = dp2;        // 更新 f(i-1)
        }

        return dp2;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(1) ✅

---

## 🔍 注意事项与技巧

### 易错点
1. **边界条件处理**：注意 `n = 0` 和 `n = 1` 的特殊情况
2. **记忆化搜索的错误**：返回值必须是 `memo[n]`，不能重复调用 `dfs`
   ```cpp
   // ❌ 错误写法
   memo[n] = dfs(n - 1) + dfs(n - 2);
   return dfs(n - 1) + dfs(n - 2);  // 重复计算！

   // ✅ 正确写法
   memo[n] = dfs(n - 1, memo) + dfs(n - 2, memo);
   return memo[n];
   ```

### 解题技巧
1. **识别斐波那契模式**：看到"前一步"、"前两步"这类描述，联想斐波那契
2. **空间优化思路**：当 `dp[i]` 只依赖前面固定几个状态时，可以用滚动变量优化空间
3. **从记忆化到递推**：记忆化搜索（自顶向下）和 DP（自底向上）可以相互转换

### 拓展思考
- **如果每次可以爬 1、2 或 3 个台阶呢？**
  状态转移方程变为：`f(n) = f(n-1) + f(n-2) + f(n-3)`

- **如果某些台阶不能踩呢？**
  可以在状态转移时跳过那些台阶

---

## 📊 相关题目

- [746. 使用最小花费爬楼梯](./746.md)
- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
- [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)
