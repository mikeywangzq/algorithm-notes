# 2466. [统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/)

## 📋 题目描述

给你整数 `zero`、`one`、`low` 和 `high`，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：

- 将 `'0'` 在字符串末尾添加 `zero` 次。
- 将 `'1'` 在字符串末尾添加 `one` 次。

当字符串长度在 `[low, high]` 之间（包含）时，我们称这个字符串是**好**字符串。

请你返回满足以上要求的**不同**好字符串的数目。由于答案可能很大，请将结果对 `10^9 + 7` **取余**后返回。

**示例 1：**
```
输入：low = 3, high = 3, zero = 1, one = 1
输出：8
解释：
一个可能的好字符串是 "011" 。
可以这样构造得到："" -> "0" -> "01" -> "011" 。
从 "" 开始，长度为 3 的字符串共有 8 个："000", "001", "010", "011", "100", "101", "110", "111"。
```

**示例 2：**
```
输入：low = 2, high = 3, zero = 1, one = 2
输出：5
解释：
长度为 2 的好字符串："00", "11"
长度为 3 的好字符串："000", "110", "011"
```

**提示：**
- `1 <= low <= high <= 10^5`
- `1 <= zero, one <= low`

---

## 💡 解题思路

这道题是 [70. 爬楼梯](./70_climb_the_stairs.md) 的变形，从"固定步数"推广到"可变步数"。

### 关键理解

1. **构造过程类似爬楼梯**：
   - 每次添加 `zero` 个 '0'，相当于爬 `zero` 步
   - 每次添加 `one` 个 '1'，相当于爬 `one` 步
   - 目标是到达长度 `[low, high]` 之间

2. **计数问题**：
   - 求有多少种方法构造出长度为 `i` 的字符串
   - 与字符串内容无关，只与长度有关

3. **区间求和**：
   - 答案是长度为 `low` 到 `high` 的所有方案数之和

### 思路分析

**状态定义：**
- `f(i)` 表示构造长度为 `i` 的字符串的方案数

**状态转移方程：**

要到达长度 `i`，可以从两个位置到达：
1. 从长度 `i - zero` 添加 `zero` 个 '0'
2. 从长度 `i - one` 添加 `one` 个 '1'

因此：
$$f(i) = \begin{cases}
0 & i < 0 \\
1 & i = 0 \\
f(i - \text{zero}) + f(i - \text{one}) & i > 0
\end{cases}$$

**边界条件：**
- `f(0) = 1`（空字符串，1 种方案）

**最终答案：**
$$\text{ans} = \sum_{i=\text{low}}^{\text{high}} f(i) \bmod (10^9 + 7)$$

### 图解示例

对于 `low = 2, high = 3, zero = 1, one = 2`：

```
长度变化过程：

f(0) = 1  (空字符串)

f(1) = f(0) = 1
  方案："0"

f(2) = f(1) + f(0) = 2
  方案："00", "11"

f(3) = f(2) + f(1) = 3
  方案："000", "011", "110"

答案 = f(2) + f(3) = 2 + 3 = 5
```

---

## 💻 代码实现

### 方法：动态规划

```cpp
class Solution {
public:
    int countGoodStrings(int low, int high, int zero, int one) {
        const int MOD = 1e9 + 7;

        // f[i] 表示长度为 i 的字符串的构造方案数
        vector<int> f(high + 1, 0);
        f[0] = 1;  // 空字符串

        // 计算每个长度的方案数
        for (int i = 1; i <= high; i++) {
            // 从 i - zero 添加 zero 个 '0'
            if (i >= zero) {
                f[i] = (f[i] + f[i - zero]) % MOD;
            }

            // 从 i - one 添加 one 个 '1'
            if (i >= one) {
                f[i] = (f[i] + f[i - one]) % MOD;
            }
        }

        // 累加 [low, high] 范围内的方案数
        int ans = 0;
        for (int i = low; i <= high; i++) {
            ans = (ans + f[i]) % MOD;
        }

        return ans;
    }
};
```

**代码解析：**
1. `f[i]` 表示长度为 `i` 的字符串方案数
2. 状态转移：从 `i - zero` 和 `i - one` 转移过来
3. 最后累加 `[low, high]` 范围内的所有方案数

**复杂度分析：**
- 时间复杂度：O(high)
- 空间复杂度：O(high)

---

### 优化：边计算边累加

可以在计算 `f[i]` 的同时累加答案，避免最后再遍历一次：

```cpp
class Solution {
public:
    int countGoodStrings(int low, int high, int zero, int one) {
        const int MOD = 1e9 + 7;

        vector<int> f(high + 1, 0);
        f[0] = 1;

        int ans = 0;

        for (int i = 1; i <= high; i++) {
            if (i >= zero) {
                f[i] = (f[i] + f[i - zero]) % MOD;
            }
            if (i >= one) {
                f[i] = (f[i] + f[i - one]) % MOD;
            }

            // 如果在范围内，累加到答案
            if (i >= low) {
                ans = (ans + f[i]) % MOD;
            }
        }

        return ans;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(high)
- 空间复杂度：O(high)

---

## 🔍 注意事项与技巧

### 易错点

1. **取模问题**
   - 每次累加后都要取模
   - 最终答案也要取模

2. **边界条件**
   - `f[0] = 1` 是必需的
   - 判断 `i >= zero` 和 `i >= one` 避免数组越界

3. **累加范围**
   - 只累加 `[low, high]` 范围内的方案数
   - 不是 `f[high]`，而是区间和

### 解题技巧

1. **识别爬楼梯变形**
   - 看到"每次可以跳 x 步或 y 步"
   - 立即联想到爬楼梯模型

2. **状态转移**
   - 从"前面的状态"转移到"当前状态"
   - `f[i]` 依赖 `f[i - zero]` 和 `f[i - one]`

3. **区间求和**
   - 问题要求的是区间内的总方案数
   - 需要累加，不是单点查询

### 与爬楼梯的对比

| 特征 | 70. 爬楼梯 | 2466. 构造字符串 |
|------|----------|----------------|
| 每次步数 | 固定（1 或 2） | 可变（zero 或 one） |
| 目标 | 到达第 n 阶 | 长度在 [low, high] |
| 答案 | f(n) | Σf(i), i∈[low,high] |

---

## 📊 状态转移示例

对于 `low = 2, high = 3, zero = 1, one = 2`：

```
f[0] = 1

f[1] = f[0] = 1
  (i >= zero=1, 加 f[0]=1)

f[2] = f[1] + f[0] = 1 + 1 = 2
  (i >= zero=1, 加 f[1]=1)
  (i >= one=2, 加 f[0]=1)

f[3] = f[2] + f[1] = 2 + 1 = 3
  (i >= zero=1, 加 f[2]=2)
  (i >= one=2, 加 f[1]=1)

答案 = f[2] + f[3] = 2 + 3 = 5
```

### 方案枚举

```
长度 2：
  "00": 添加 zero(1) 两次
  "11": 添加 one(2) 一次

长度 3：
  "000": 添加 zero(1) 三次
  "011": 添加 zero(1) 一次，再添加 one(2) 一次
  "110": 添加 one(2) 一次，再添加 zero(1) 一次
```

---

## 🔗 相关题目

- [70. 爬楼梯](./70_climb_the_stairs.md)（基础模型）
- [377. 组合总和 IV](./377.md)（完全背包排列）
- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
- [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)

---

## 💡 递推式推导

如果 `zero = 1, one = 1`（与爬楼梯相同）：

```
f(i) = f(i-1) + f(i-1) = 2 × f(i-1)

这是指数增长：
f(0) = 1
f(1) = 2
f(2) = 4
f(3) = 8
...
f(n) = 2^n
```

如果 `zero = 1, one = 2`（类似爬楼梯）：

```
f(i) = f(i-1) + f(i-2)

这是斐波那契数列。
```

---

## 💪 总结

这道题的核心思想：
1. **爬楼梯模型的推广**：从固定步数到可变步数
2. **区间求和**：答案是多个长度的方案数之和
3. **动态规划**：自底向上计算每个长度的方案数

**关键点：**
- 识别出是爬楼梯的变形
- 理解状态转移：`f(i) = f(i-zero) + f(i-one)`
- 注意取模和区间累加

掌握这道题，可以理解**如何将基础 DP 模型推广到更一般的情况**。

**学习路径：**
1. [70. 爬楼梯](./70_climb_the_stairs.md) - 理解基础模型
2. [377. 组合总和 IV](./377.md) - 推广到多个选择
3. **本题** - 加入区间求和
