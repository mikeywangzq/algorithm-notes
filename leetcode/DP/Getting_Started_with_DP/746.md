# 746. [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

## 📋 题目描述

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**
```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**
```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

**提示：**
- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

---

## 💡 解题思路

这道题是 [70. 爬楼梯](./70_climb_the_stairs.md) 的变形，从求"方案数"变成了求"最小花费"。

### 思路分析

**关键理解：**
- `cost[i]` 表示**从第 `i` 个台阶向上爬的花费**
- 目标是到达"楼梯顶部"，即超过最后一个台阶（第 `n` 个位置）
- 可以从第 0 或第 1 个台阶开始，这两个起点都不需要花费

要到达第 `i` 个台阶，可以从两个位置到达：
1. 从第 `i-1` 个台阶爬 1 步（花费 `cost[i-1]`）
2. 从第 `i-2` 个台阶爬 2 步（花费 `cost[i-2]`）

**状态定义：**
- `f(i)` 表示到达第 `i` 个台阶的最小花费

**状态转移方程：**
$$f(i) = \min(f(i-1) + \text{cost}[i-1], f(i-2) + \text{cost}[i-2])$$

**边界条件：**
- `f(0) = 0`（从第 0 个台阶开始，不需要花费）
- `f(1) = 0`（从第 1 个台阶开始，不需要花费）

**最终答案：**
- `f(n)`，其中 `n = cost.length`（到达楼梯顶部）

### 图解示例

对于 `cost = [1,100,1,1,1,100,1,1,100,1]`：

```
台阶:  [1,  100,  1,  1,  1,  100,  1,  1,  100,  1]  (顶部)
索引:   0    1    2   3   4    5    6   7    8    9    10

路径: 0 -> 2 -> 4 -> 6 -> 7 -> 9 -> 10
花费: 1 +  1 +  1 +  1 +  1 +  1  = 6
```

---

## 💻 代码实现

### 方法一：动态规划（数组）

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        // dp[i] 表示到达第 i 个台阶的最小花费
        vector<int> dp(n + 1, 0);

        // 初始状态：可以免费站在第 0 或第 1 个台阶
        dp[0] = 0;
        dp[1] = 0;

        // 状态转移
        for (int i = 2; i <= n; i++) {
            // 到达第 i 个台阶的最小花费
            // = min(从 i-1 爬上来, 从 i-2 爬上来)
            dp[i] = min(dp[i - 1] + cost[i - 1],
                        dp[i - 2] + cost[i - 2]);
        }

        return dp[n];
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

---

### 方法二：动态规划（空间优化）⭐ 推荐

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        // dp0 = f(i-2), dp1 = f(i-1)
        int dp0 = 0, dp1 = 0;

        for (int i = 2; i <= n; i++) {
            // 计算 f(i)
            int dp2 = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);

            // 滚动更新
            dp0 = dp1;
            dp1 = dp2;
        }

        return dp1;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(1) ✅

---

### 方法三：记忆化搜索

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> memo(n + 1, -1);
        return dfs(cost, n, memo);
    }

private:
    // dfs(i) 表示到达第 i 个台阶的最小花费
    int dfs(vector<int>& cost, int i, vector<int>& memo) {
        // 边界条件：起点不需要花费
        if (i == 0 || i == 1) {
            return 0;
        }

        // 记忆化
        if (memo[i] != -1) {
            return memo[i];
        }

        // 状态转移
        memo[i] = min(dfs(cost, i - 1, memo) + cost[i - 1],
                      dfs(cost, i - 2, memo) + cost[i - 2]);

        return memo[i];
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

---

## 🔍 注意事项与技巧

### 易错点

1. **题意理解错误**
   - `cost[i]` 是**从第 i 个台阶向上爬的花费**，不是到达第 i 个台阶的花费
   - 目标是到达**第 n 个位置**（楼梯顶部），不是第 n-1 个台阶

2. **边界条件**
   - 可以从第 0 或第 1 个台阶开始，所以 `f(0) = f(1) = 0`
   - 最终答案是 `f(n)`，不是 `min(f(n-1), f(n-2))`

3. **数组越界**
   - dp 数组的大小应该是 `n + 1`，因为要计算到第 n 个位置

### 解题技巧

1. **与爬楼梯的对比**

| 题目 | 状态转移方程 | 目标 |
|------|------------|------|
| 70. 爬楼梯 | `f(i) = f(i-1) + f(i-2)` | 求方案数 |
| 746. 爬楼梯（最小花费） | `f(i) = min(f(i-1) + cost[i-1], f(i-2) + cost[i-2])` | 求最小值 |

2. **DP 三要素**
   - **状态定义**：到达第 i 个台阶的最小花费
   - **转移方程**：从 i-1 或 i-2 转移，取最小
   - **边界条件**：起点花费为 0

3. **调试技巧**
   - 画出 dp 数组的变化过程
   - 手算小样例验证理解

### 状态转移过程示例

对于 `cost = [10, 15, 20]`：

```
台阶:  [10,  15,  20]  (顶部)
索引:   0    1    2     3

dp 数组计算过程：
dp[0] = 0  (起点)
dp[1] = 0  (起点)
dp[2] = min(dp[1] + cost[1], dp[0] + cost[0])
      = min(0 + 15, 0 + 10) = 10
dp[3] = min(dp[2] + cost[2], dp[1] + cost[1])
      = min(10 + 20, 0 + 15) = 15

答案：15
```

---

## 📊 相关题目

- [70. 爬楼梯](./70_climb_the_stairs.md)（基础版）
- [198. 打家劫舍](./198.md)（不能选相邻元素）
- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
- [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)

---

## 💪 总结

这道题是爬楼梯的进阶版：
1. 加入了"花费"的概念
2. 从求"方案数"变成了求"最小花费"
3. 状态转移从"加法"变成了"取最小值"

掌握这道题，可以理解如何将基础 DP 模型应用到实际问题中。
