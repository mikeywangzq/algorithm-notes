# 2320. [统计放置房子的方式数](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/)

## 📋 题目描述

一条街道上共有 `n × 2` 个**地块**，街道的**两侧**各有 `n` 个地块。每一边的地块都按从 `1` 到 `n` 编号。每个地块上都可以放置一所房子。

现要求街道**同一侧**不能存在两所房子**相邻**的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 `10^9 + 7` **取余**后再返回。

注意，如果一所房子放置在这条街某一侧上的第 `i` 个地块，**不影响**在另一侧的第 `i` 个地块放置房子。

**示例 1：**
```
输入：n = 1
输出：4
解释：
可能的放置方式：
1. 所有地块都不放置房子。
2. 一所房子放在街道的某一侧。
3. 一所房子放在街道的另一侧。
4. 放置两所房子，街道两侧各放置一所。
```

**示例 2：**
```
输入：n = 2
输出：9
解释：如上图所示，共有 9 种可能的放置方式。
```

**提示：**
- `1 <= n <= 10^4`

---

## 💡 解题思路

这道题是**两个独立的打家劫舍问题的组合**。

### 关键观察

1. **两侧独立**：
   - 街道两侧的房子互不影响
   - 左侧的方案数和右侧的方案数独立

2. **单侧问题**：
   - 每一侧都是"不能放置相邻房子"的问题
   - 类似 [198. 打家劫舍](./198.md)，但这里是求**方案数**而不是最大值

3. **乘法原理**：
   - 总方案数 = 左侧方案数 × 右侧方案数

### 思路分析

**单侧问题的状态定义：**
- `f(i)` 表示在 `i` 个地块上放置房子的方案数（相邻不能同时放）

**状态转移方程：**

对于第 `i` 个地块，有两种选择：
1. **不放房子**：前 `i-1` 个地块的方案数 = `f(i-1)`
2. **放房子**：第 `i-1` 个不能放，前 `i-2` 个的方案数 = `f(i-2)`

因此：
$$f(i) = f(i-1) + f(i-2)$$

**边界条件：**
- `f(0) = 1`（0 个地块，1 种方案：都不放）
- `f(1) = 2`（1 个地块，2 种方案：放或不放）

**最终答案：**
$$\text{ans} = f(n) \times f(n) \bmod (10^9 + 7)$$

### 为什么是斐波那契数列？

单侧的递推公式 `f(i) = f(i-1) + f(i-2)` 就是斐波那契数列！

```
f(0) = 1
f(1) = 2
f(2) = 3
f(3) = 5
f(4) = 8
...
```

### 图解示例

对于 `n = 2`：

```
单侧方案（n=2）：
地块:  1  2

方案1: □  □   (都不放)
方案2: ■  □   (只放1)
方案3: □  ■   (只放2)

共 3 种方案：f(2) = 3

两侧方案：
左侧 3 种 × 右侧 3 种 = 9 种

详细列举：
左 | 右 | 总
□□ | □□ | 都不放
□□ | ■□ | 右放1
□□ | □■ | 右放2
■□ | □□ | 左放1
■□ | ■□ | 左放1，右放1
■□ | □■ | 左放1，右放2
□■ | □□ | 左放2
□■ | ■□ | 左放2，右放1
□■ | □■ | 左放2，右放2
```

---

## 💻 代码实现

### 方法一：预处理 + 查表

```cpp
const int MOD = 1e9 + 7;
const int MX = 1e4 + 10;

// 预处理数组：dp[i] 表示 i 个地块的单侧方案数
int dp[MX] = {1, 2};

// 静态初始化：只执行一次
int init = []() {
    for (int i = 2; i < MX; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;
    }
    return 0;
}();

class Solution {
public:
    int countHousePlacements(int n) {
        // 两侧独立，方案数相乘
        return (long long)dp[n] * dp[n] % MOD;
    }
};
```

**代码解析：**
1. 预处理所有可能的 `n` 值对应的单侧方案数
2. 使用 lambda 表达式实现静态初始化
3. 查表时直接相乘，注意取模

**为什么要预处理？**
- 避免每次调用都重新计算
- 空间换时间，提高效率

**复杂度分析：**
- 时间复杂度：O(1)（预处理 O(MX) 只执行一次）
- 空间复杂度：O(MX)

---

### 方法二：动态规划（不预处理）

如果不想使用全局变量，可以每次调用时计算：

```cpp
class Solution {
public:
    int countHousePlacements(int n) {
        const int MOD = 1e9 + 7;

        // dp[i] 表示 i 个地块的单侧方案数
        vector<long long> dp(n + 1);
        dp[0] = 1;
        dp[1] = 2;

        for (int i = 2; i <= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;
        }

        // 两侧相乘
        return dp[n] * dp[n] % MOD;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

---

### 方法三：空间优化

只需要记录前两个状态：

```cpp
class Solution {
public:
    int countHousePlacements(int n) {
        const int MOD = 1e9 + 7;

        long long dp0 = 1, dp1 = 2;

        for (int i = 2; i <= n; i++) {
            long long dp2 = (dp1 + dp0) % MOD;
            dp0 = dp1;
            dp1 = dp2;
        }

        // n==1 时，dp1 = 2
        long long singleSide = (n == 1) ? 2 : dp1;
        return singleSide * singleSide % MOD;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
- 空间复杂度：O(1) ✅

---

## 🔍 注意事项与技巧

### 易错点

1. **取模问题**
   - 单侧方案数要取模
   - 两侧相乘后也要取模
   - 使用 `long long` 避免溢出

2. **边界条件**
   - `dp[0] = 1`：0 个地块，1 种方案
   - `dp[1] = 2`：1 个地块，2 种方案

3. **乘法顺序**
   ```cpp
   // ✅ 正确：先转换为 long long
   return (long long)dp[n] * dp[n] % MOD;

   // ❌ 错误：可能溢出
   return dp[n] * dp[n] % MOD;
   ```

### 解题技巧

1. **问题分解**
   - 复杂问题 → 简单子问题
   - 两侧独立 → 单侧方案数相乘

2. **识别斐波那契**
   - 递推公式是 `f(i) = f(i-1) + f(i-2)`
   - 类似爬楼梯问题

3. **乘法原理**
   - 两个独立事件：左侧 + 右侧
   - 总方案数 = 左侧方案数 × 右侧方案数

### 为什么单侧方案数是斐波那契？

```
n=0: 1 种 (都不放)
n=1: 2 种 (放或不放)
n=2: 3 种 (□□, ■□, □■)
n=3: 5 种 (□□□, ■□□, □■□, □□■, ■□■)
n=4: 8 种
...

递推关系：
f(i) = f(i-1) + f(i-2)
     = (不放第i个) + (放第i个)
```

---

## 📊 示例推导

### 单侧方案数

```
n=0: dp[0] = 1
n=1: dp[1] = 2
n=2: dp[2] = dp[1] + dp[0] = 2 + 1 = 3
n=3: dp[3] = dp[2] + dp[1] = 3 + 2 = 5
n=4: dp[4] = dp[3] + dp[2] = 5 + 3 = 8
```

### 两侧方案数

```
n=1: 2 × 2 = 4
n=2: 3 × 3 = 9
n=3: 5 × 5 = 25
n=4: 8 × 8 = 64
```

---

## 🔗 相关题目

- [70. 爬楼梯](./70_climb_the_stairs.md)（斐波那契基础）
- [198. 打家劫舍](./198.md)（相邻不能选）
- [213. 打家劫舍 II](./213.md)（环形问题）
- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

---

## 💡 问题对比

| 题目 | 单侧递推式 | 目标 | 最终答案 |
|------|----------|------|---------|
| 70. 爬楼梯 | `f(i) = f(i-1) + f(i-2)` | 求方案数 | `f(n)` |
| 198. 打家劫舍 | `f(i) = max(f(i-1), f(i-2) + nums[i])` | 求最大值 | `f(n)` |
| 2320. 放置房子 | `f(i) = f(i-1) + f(i-2)` | 求方案数 | `f(n) × f(n)` |

---

## 💪 总结

这道题的核心思想：
1. **问题分解**：两侧独立，分别计算
2. **单侧递推**：类似爬楼梯的斐波那契数列
3. **乘法原理**：总方案数 = 左侧 × 右侧

**关键点：**
- 识别出单侧是打家劫舍/爬楼梯模型
- 理解两侧独立性，应用乘法原理
- 注意取模和溢出问题

掌握这道题，可以理解**如何将独立子问题组合**，这是组合计数的重要技巧。
