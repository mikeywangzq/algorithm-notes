# 377. [组合总和 IV](https://leetcode.cn/problems/combination-sum-iv/)

## 📋 题目描述

给你一个由**不同**整数组成的数组 `nums`，和一个目标整数 `target`。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**
```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**
```
输入：nums = [9], target = 3
输出：0
```

**提示：**
- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素**互不相同**
- `1 <= target <= 1000`

**进阶：** 如果给定的数组中含有负数会发生什么？题目会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

---

## 💡 解题思路

这道题看起来像是"组合"问题，但实际上是**排列**问题，因为**顺序不同视为不同方案**。

### 关键理解

1. **排列 vs 组合**：
   - 组合：`[1,2]` 和 `[2,1]` 是同一个
   - 排列：`[1,2]` 和 `[2,1]` 是不同的
   - 本题要求的是排列数

2. **完全背包变种**：
   - 每个数字可以无限使用
   - 但要考虑顺序

### 思路分析

**状态定义：**
- `f(i)` 表示和为 `i` 的排列数量

**状态转移方程：**

对于和为 `i`，可以从哪些状态转移过来？
- 如果最后选择 `nums[0]`，那么前面的和是 `i - nums[0]`
- 如果最后选择 `nums[1]`，那么前面的和是 `i - nums[1]`
- ...
- 如果最后选择 `nums[j]`，那么前面的和是 `i - nums[j]`

因此：
$$f(i) = \sum_{j=0}^{n-1} f(i - \text{nums}[j]) \quad (\text{当 } i \geq \text{nums}[j])$$

**边界条件：**
- `f(0) = 1`（和为 0，只有一种方案：不选任何数）

### 爬楼梯的推广

这道题可以看作是 [70. 爬楼梯](./70_climb_the_stairs.md) 的推广：
- 爬楼梯：每次可以爬 1 或 2 步
- 本题：每次可以"爬" `nums[i]` 步

---

## 💻 代码实现

### 方法一：动态规划（完全背包）

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        int n = nums.size();

        // dp[i] 表示和为 i 的排列数量
        // 使用 unsigned 防止溢出（题目保证答案在 int 范围内）
        vector<unsigned int> dp(target + 1, 0);

        // 边界条件：和为 0，只有 1 种方案
        dp[0] = 1;

        // 外层循环：枚举目标和
        for (int i = 1; i <= target; i++) {
            // 内层循环：枚举最后选择的数字
            for (int j = 0; j < n; j++) {
                // 如果可以选择 nums[j]
                if (i >= nums[j]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }

        return dp[target];
    }
};
```

**为什么是排列而不是组合？**

循环顺序决定了是排列还是组合：

```cpp
// 本题代码（排列）
for (int i = 1; i <= target; i++) {      // 外层：目标和
    for (int j = 0; j < n; j++) {         // 内层：物品
        if (i >= nums[j]) {
            dp[i] += dp[i - nums[j]];
        }
    }
}

// 如果求组合（交换循环顺序）
for (int j = 0; j < n; j++) {             // 外层：物品
    for (int i = nums[j]; i <= target; i++) { // 内层：目标和
        dp[i] += dp[i - nums[j]];
    }
}
```

**复杂度分析：**
- 时间复杂度：O(target × n)
- 空间复杂度：O(target)

---

### 方法二：记忆化搜索

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> memo(target + 1, -1);
        return dfs(nums, target, memo);
    }

private:
    // dfs(i) 表示和为 i 的排列数量
    int dfs(vector<int>& nums, int target, vector<int>& memo) {
        // 边界条件
        if (target == 0) return 1;
        if (target < 0) return 0;

        // 记忆化
        if (memo[target] != -1) {
            return memo[target];
        }

        // 枚举最后选择的数字
        long long res = 0;
        for (int num : nums) {
            if (target >= num) {
                res += dfs(nums, target - num, memo);
            }
        }

        // 防止溢出（题目保证答案在 int 范围内）
        memo[target] = res;
        return memo[target];
    }
};
```

**复杂度分析：**
- 时间复杂度：O(target × n)
- 空间复杂度：O(target)

---

## 🔍 注意事项与技巧

### 易错点

1. **整数溢出**
   - 中间计算可能超过 int 范围
   - 解决方法：使用 `unsigned int` 或在累加时判断

2. **排列 vs 组合**
   - 循环顺序决定结果：
     - 外层目标和 → 排列（考虑顺序）
     - 外层物品 → 组合（不考虑顺序）

3. **边界条件**
   - `dp[0] = 1` 是必需的
   - 表示"和为 0 的方案数是 1"

### 解题技巧

1. **识别问题类型**
   - 看到"无限次使用" → 完全背包
   - 看到"顺序不同视为不同" → 排列
   - 看到"顺序相同视为相同" → 组合

2. **状态定义**
   - 按"目标和"定义状态
   - 转移时枚举"最后选择的数字"

3. **循环顺序**
   ```
   求排列数：
   for target:
       for nums:

   求组合数：
   for nums:
       for target:
   ```

### 为什么使用 unsigned int？

题目保证答案在 32 位整数范围内，但中间计算可能溢出：

```cpp
vector<unsigned int> dp(target + 1, 0);
```

使用 `unsigned int` 的好处：
- 自动取模（溢出后会回绕）
- 最终结果仍然正确

---

## 📊 示例推导

对于 `nums = [1,2,3], target = 4`：

```
dp[0] = 1  (空序列)

dp[1] = dp[0] = 1
  方案：[1]

dp[2] = dp[1] + dp[0] = 2
  方案：[1,1], [2]

dp[3] = dp[2] + dp[1] + dp[0] = 4
  方案：[1,1,1], [1,2], [2,1], [3]

dp[4] = dp[3] + dp[2] + dp[1] = 7
  方案：[1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [1,3], [3,1], [2,2]
```

---

## 🔗 相关题目

### 同类型题目

- [70. 爬楼梯](./70_climb_the_stairs.md)（基础版）
- [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)（求最少硬币数）
- [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)（求组合数）

### 对比学习

| 题目 | 类型 | 循环顺序 | 目标 |
|------|------|---------|------|
| 377. 组合总和 IV | 排列 | target → nums | 求排列数 |
| 518. 零钱兑换 II | 组合 | nums → target | 求组合数 |

---

## 💡 拓展思考

**进阶问题：如果 nums 中有负数？**

1. **问题变化**：
   - 可能产生无限循环（如 `[1, -1]`）
   - DP 无法终止

2. **需要的限制**：
   - 限制序列的最大长度
   - 或保证没有和为 0 的子序列

---

## 💪 总结

这道题的核心知识点：
1. **完全背包**：物品可以无限次使用
2. **排列问题**：循环顺序是"目标和 → 物品"
3. **状态转移**：枚举最后选择的数字

通过这道题，可以理解**排列与组合在 DP 中的区别**，这是背包问题的重要知识点。
