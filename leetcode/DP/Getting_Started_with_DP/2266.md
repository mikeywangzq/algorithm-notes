# 2266. [统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)

## 📋 题目描述

Alice 在给 Bob 用手机打字。数字到字母的**对应**如下图所示。

![键盘映射](https://assets.leetcode.com/uploads/2021/11/11/1200px-telephone-keypad2svg.png)

为了**打出**一个字母，Alice 需要**按**对应字母 `i` 次，`i` 是该字母在这个按键上所处的位置。

- 比方说，为了按出字母 `'s'` ，Alice 需要按 `'7'` 四次。类似的， Alice 需要按 `'5'` 两次得到字母 `'k'` 。
- 注意，数字 `'0'` 和 `'1'` 不映射到任何字母，所以 Alice **不**使用它们。

但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了**按键的字符串信息**。

- 比方说，Alice 发出的信息为 `"bob"` ，Bob 将收到字符串 `"2266622"` 。

给你一个字符串 `pressedKeys` ，表示 Bob 收到的字符串，请你返回 Alice **总共可能发出多少种文字信息**。

由于答案可能很大，将它对 `10^9 + 7` **取余**后返回。

**示例 1：**
```
输入：pressedKeys = "22233"
输出：8
解释：
Alice 可能发出的文字信息包括：
"aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae", "ce"
由于总共有 8 种可能的信息，所以我们返回 8 。
```

**示例 2：**
```
输入：pressedKeys = "222222222222222222222222222222222222"
输出：82876089
解释：
总共有 2082876103 种 Alice 可能发出的文字信息。
由于我们需要将答案对 10^9 + 7 取余，所以我们返回 2082876103 % (10^9 + 7) = 82876089 。
```

**提示：**
- `1 <= pressedKeys.length <= 10^5`
- `pressedKeys` 只包含数字 `[2-9]` 。

---

## 💡 解题思路

这道题本质上是一个**分组 + 动态规划**问题。

### 关键观察

1. **键盘映射规则**：
   - 数字 2-6, 8：每个按键对应 3 个字母
   - 数字 7, 9：每个按键对应 4 个字母

2. **分组独立性**：
   - 连续相同的数字可以分成一组
   - 每组内的解码方案数独立
   - 总方案数 = 各组方案数的乘积

3. **单组的解码方案数**：
   - 对于长度为 `n` 的连续相同数字
   - 类似于爬楼梯问题，每次可以走 1-3 步（或 1-4 步）

### 思路分析

对于一段连续相同的数字，设长度为 `n`：

**如果数字不是 7 或 9**（对应 3 个字母）：
- 可以分解为：最后 1 个、最后 2 个、最后 3 个
- 递推公式：`f[i] = f[i-1] + f[i-2] + f[i-3]`

**如果数字是 7 或 9**（对应 4 个字母）：
- 可以分解为：最后 1 个、最后 2 个、最后 3 个、最后 4 个
- 递推公式：`g[i] = g[i-1] + g[i-2] + g[i-3] + g[i-4]`

### 算法流程

1. **预处理**：提前计算所有长度的方案数（最大 10^5）
2. **分组**：遍历字符串，识别连续相同数字
3. **累乘**：将每组的方案数相乘（记得取模）

### 图解示例

对于 `pressedKeys = "22233"`：

```
分组：
  "222" (长度3, 数字2) -> f[3] = 4 种方案
    - "a", "a", "a" -> "aaa"
    - "a", "b"      -> "ab"
    - "b", "a"      -> "ba"
    - "c"           -> "c"

  "33" (长度2, 数字3) -> f[2] = 2 种方案
    - "d", "d" -> "dd"
    - "e"      -> "e"

总方案数 = 4 × 2 = 8
```

---

## 💻 代码实现

### 方法：预处理 + 分组计数

```cpp
const int MOD = 1e9 + 7;
const int MX = 1e5 + 10;

// 预处理数组（全局变量，所有测试用例共享）
long long f[MX], g[MX];

// 静态初始化：只执行一次
int init = []() {
    // f[i]: 长度为 i 的连续相同数字（2-6, 8）的方案数
    // g[i]: 长度为 i 的连续相同数字（7, 9）的方案数

    // 边界条件
    f[0] = g[0] = 1;
    f[1] = g[1] = 1;
    f[2] = g[2] = 2;
    f[3] = g[3] = 4;

    // 递推计算
    for (int i = 4; i < MX; i++) {
        // 2-6, 8: 最多 3 个字母
        f[i] = (f[i - 1] + f[i - 2] + f[i - 3]) % MOD;

        // 7, 9: 最多 4 个字母
        g[i] = (g[i - 1] + g[i - 2] + g[i - 3] + g[i - 4]) % MOD;
    }

    return 0;
}();

class Solution {
public:
    int countTexts(string pressedKeys) {
        int n = pressedKeys.length();
        long long ans = 1;
        int cnt = 0;

        for (int i = 0; i < n; i++) {
            char c = pressedKeys[i];
            cnt++;

            // 当前数字结束（下一个不同 或 到达末尾）
            if (i == n - 1 || c != pressedKeys[i + 1]) {
                // 根据数字选择 f 或 g
                ans = ans * (c != '7' && c != '9' ? f[cnt] : g[cnt]) % MOD;
                cnt = 0;  // 重置计数器
            }
        }

        return ans;
    }
};
```

**代码解析：**

1. **预处理部分**：
   - 使用 lambda 表达式实现静态初始化
   - `f` 和 `g` 数组在第一次调用前就计算好了
   - 所有测试用例共享这些数组，避免重复计算

2. **主逻辑**：
   - 遍历字符串，用 `cnt` 统计连续相同数字的个数
   - 遇到不同数字或到达末尾时，累乘对应的方案数
   - 根据数字是否为 7 或 9，选择 `f[cnt]` 或 `g[cnt]`

**复杂度分析：**
- 时间复杂度：O(MX + n)，预处理 O(MX)，遍历 O(n)
- 空间复杂度：O(MX)，预处理数组

---

### 递推公式推导

#### f 数组（3 个字母）

```
f[0] = 1  (空串，1 种方案)
f[1] = 1  (1 个数字 -> 1 个字母)
f[2] = 2  (2 个数字 -> "aa" 或 "b")
f[3] = 4  (3 个数字 -> "aaa", "ab", "ba", "c")

f[i] = f[i-1] + f[i-2] + f[i-3]
     = (最后1个) + (最后2个) + (最后3个)
```

#### g 数组（4 个字母）

```
g[0] = 1
g[1] = 1
g[2] = 2
g[3] = 4
g[4] = 8  (4 个数字 -> "aaaa", "aab", "aba", "baa", "ab", "ba", "ac", "d")

g[i] = g[i-1] + g[i-2] + g[i-3] + g[i-4]
```

---

## 🔍 注意事项与技巧

### 易错点

1. **取模问题**
   - 每次乘法后都要取模，避免溢出
   - 累乘时：`ans = ans * f[cnt] % MOD`

2. **边界条件**
   - `f[0] = g[0] = 1`，表示空串的方案数
   - 初始化前几项：`f[1], f[2], f[3]` 等

3. **分组逻辑**
   - 判断条件：`i == n - 1 || c != pressedKeys[i + 1]`
   - 别忘了在累乘后重置 `cnt = 0`

### 解题技巧

1. **识别问题模式**
   - 连续相同元素的分组问题
   - 每组内部是独立的子问题
   - 类似爬楼梯的变种

2. **预处理优化**
   - 使用静态初始化，避免每次调用都重新计算
   - 空间换时间，提前算好所有可能长度的方案数

3. **数学规律**
   - `f` 数组类似泰波那契数列（每项是前 3 项之和）
   - `g` 数组是 4 项和的递推

### 为什么要预处理？

| 方法 | 时间复杂度 | 说明 |
|------|----------|------|
| 每次调用都计算 | O(MX × 测试用例数) | 重复计算，超时 |
| 预处理 + 查表 | O(MX + n × 测试用例数) | 只计算一次 ✅ |

---

## 📊 数组值示例

前几项的值：

```
f[0] = 1
f[1] = 1
f[2] = 2
f[3] = 4
f[4] = 7   (1+2+4)
f[5] = 13  (2+4+7)
f[6] = 24  (4+7+13)
...

g[0] = 1
g[1] = 1
g[2] = 2
g[3] = 4
g[4] = 8   (1+2+4+1)
g[5] = 15  (2+4+8+1)
g[6] = 29  (4+8+15+2)
...
```

---

## 💡 拓展思考

1. **如果键盘映射改变怎么办？**
   - 修改递推公式，根据最多字母数调整

2. **如果要求具体的方案呢？**
   - 需要记录路径，使用回溯或 BFS

3. **类似问题**
   - 解码方法（LeetCode 91）
   - 爬楼梯的变种

---

## 📊 相关题目

- [70. 爬楼梯](./70_climb_the_stairs.md)（基础递推）
- [91. 解码方法](https://leetcode.cn/problems/decode-ways/)（类似思路）
- [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)（三项递推）

---

## 💪 总结

这道题的核心思想：
1. **分组处理**：将问题分解为独立的子问题
2. **递推计算**：每组内部是类似爬楼梯的 DP
3. **预处理优化**：提前计算，避免重复

掌握这道题，可以理解如何处理**分组 + DP** 类型的问题。
