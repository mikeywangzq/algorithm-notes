# 740. [删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)

## 📋 题目描述

给你一个整数数组 `nums`，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]`，删除它并获得 `nums[i]` 的点数。之后，你必须删除**所有**等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。

开始你拥有 `0` 个点数。返回你能通过这些操作获得的**最大点数**。

**示例 1：**
```
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
```

**示例 2：**
```
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
```

**提示：**
- `1 <= nums.length <= 2 * 10^4`
- `1 <= nums[i] <= 10^4`

---

## 💡 解题思路

这道题乍看很复杂，但**本质上是打家劫舍问题**！

### 关键观察

1. **选择的完整性**：
   - 如果选择某个数 `x`，那么**所有** `x` 都应该被选择
   - 因为选一个 `x` 会删除所有 `x-1` 和 `x+1`，不如把所有 `x` 都选上

2. **转化为打家劫舍**：
   - 将问题转化为：在数轴上，选择一些数字，不能选相邻的数字
   - 这和 [198. 打家劫舍](./198.md) 完全一样！

### 思路分析

**第一步：统计每个数字的总点数**

创建一个数组 `sum`，其中 `sum[i]` 表示选择所有值为 `i` 的元素能获得的总点数。

例如：`nums = [2,2,3,3,3,4]`
```
sum[2] = 2 + 2 = 4
sum[3] = 3 + 3 + 3 = 9
sum[4] = 4
```

**第二步：打家劫舍**

在 `sum` 数组上做打家劫舍：
- `sum[i]` 表示"偷第 i 号房子"能获得的金额
- 不能选相邻的房子（因为选 `i` 会导致 `i-1` 和 `i+1` 被删除）

**状态定义：**
- `f(i)` 表示考虑前 `i` 个数字（0 到 i），能获得的最大点数

**状态转移方程：**
$$f(i) = \max(f(i-1), f(i-2) + \text{sum}[i])$$

### 图解示例

对于 `nums = [2,2,3,3,3,4]`：

```
原数组：[2, 2, 3, 3, 3, 4]

统计后：
  数字:  0  1  2  3  4  5 ...
  sum:   0  0  4  9  4  0 ...
         ↑     ↑  ↑  ↑
         |     |  |  └─ 选4，不能选3
         |     |  └──── 选3，不能选2和4
         |     └─────── 选2，不能选1和3
         └───────────── 不选

打家劫舍：
  不选2，选3，不选4 → 9 点（最优）
  选2，不选3，选4 → 4 + 4 = 8 点
```

---

## 💻 代码实现

### 方法一：统计 + 打家劫舍

```cpp
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        // 找到最大值
        int maxNum = *max_element(nums.begin(), nums.end());

        // sum[i] 表示选择所有值为 i 的元素的总点数
        vector<int> sum(maxNum + 1, 0);
        for (int num : nums) {
            sum[num] += num;
        }

        // 在 sum 数组上做打家劫舍
        return rob(sum);
    }

private:
    // 打家劫舍模板（空间优化版）
    int rob(vector<int>& nums) {
        int dp0 = 0, dp1 = 0;

        for (int x : nums) {
            int newDp = max(dp1, dp0 + x);
            dp0 = dp1;
            dp1 = newDp;
        }

        return dp1;
    }
};
```

**代码解析：**
1. 统计每个数字的总点数到 `sum` 数组
2. 在 `sum` 数组上做打家劫舍
3. 使用空间优化的打家劫舍模板

**复杂度分析：**
- 时间复杂度：O(n + max(nums))，其中 n 是数组长度
- 空间复杂度：O(max(nums))

---

### 方法二：直接在统计数组上 DP

```cpp
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int maxNum = *max_element(nums.begin(), nums.end());

        // sum[i] 表示选择所有值为 i 的元素的总点数
        vector<int> sum(maxNum + 1, 0);
        for (int num : nums) {
            sum[num] += num;
        }

        // DP：dp0 = f(i-2), dp1 = f(i-1)
        int dp0 = 0, dp1 = 0;

        for (int i = 0; i <= maxNum; i++) {
            int newDp = max(dp1, dp0 + sum[i]);
            dp0 = dp1;
            dp1 = newDp;
        }

        return dp1;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n + max(nums))
- 空间复杂度：O(max(nums))

---

### 方法三：使用哈希表优化空间（针对稀疏数据）

如果数据范围很大但数据很稀疏，可以使用哈希表：

```cpp
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        // 使用哈希表统计
        unordered_map<int, int> sum;
        for (int num : nums) {
            sum[num] += num;
        }

        // 提取所有不同的数字并排序
        vector<int> sorted;
        for (auto& [key, value] : sum) {
            sorted.push_back(key);
        }
        sort(sorted.begin(), sorted.end());

        // DP
        int dp0 = 0, dp1 = 0;
        int prev = -2;  // 上一个处理的数字

        for (int num : sorted) {
            // 如果不连续，可以把前面的都选上
            if (num - prev > 1) {
                dp0 = dp1;
            }

            int newDp = max(dp1, dp0 + sum[num]);
            dp0 = dp1;
            dp1 = newDp;
            prev = num;
        }

        return dp1;
    }
};
```

**适用场景：**
- 当 `max(nums)` 很大，但不同数字的个数很少时

**复杂度分析：**
- 时间复杂度：O(n + k log k)，k 是不同数字的个数
- 空间复杂度：O(k)

---

## 🔍 注意事项与技巧

### 易错点

1. **理解题意**
   - "删除所有等于 `nums[i] - 1` 和 `nums[i] + 1`" 不是只删一个，是删所有
   - 因此选一个 `x` 就应该选所有 `x`

2. **数组边界**
   - `sum` 数组大小应该是 `maxNum + 1`
   - 注意 `nums[i]` 可能是 0

3. **空间优化**
   - 如果 `max(nums)` 很大但数据稀疏，用哈希表
   - 否则直接用数组

### 解题技巧

1. **问题转化**
   - 复杂问题 → 简单模型
   - 删除并获得点数 → 打家劫舍

2. **两步法**
   - 第一步：统计（预处理）
   - 第二步：DP（应用模板）

3. **模板复用**
   - 识别出是打家劫舍后，直接套用模板
   - 代码简洁，不易出错

### 为什么可以贪心地选所有相同的数？

假设选了一个值为 `x` 的元素：
- 所有 `x-1` 和 `x+1` 都会被删除
- 那么剩下的 `x` 不会再受影响
- 不选白不选！

---

## 📊 状态转移示例

对于 `nums = [2,2,3,3,3,4]`：

```
统计：
sum = [0, 0, 4, 9, 4]
       i=0 1  2  3  4

DP 过程：
i=0: dp = [0, 0]     sum[0]=0, 选或不选都是0
i=1: dp = [0, 0]     sum[1]=0, 选或不选都是0
i=2: dp = [0, 4]     sum[2]=4, 选2获得4点
i=3: dp = [4, 9]     sum[3]=9, 不选2，选3获得9点
i=4: dp = [9, 9]     sum[4]=4, 不选4（9 > 4+4）

答案：9
```

---

## 🔗 相关题目

- [198. 打家劫舍](./198.md)（核心模型）
- [213. 打家劫舍 II](./213.md)（环形变种）
- [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)（树形 DP）

---

## 💡 问题对比

| 特征 | 198. 打家劫舍 | 740. 删除并获得点数 |
|------|-------------|-----------------|
| 数据结构 | 数组 | 数组（需要预处理）|
| 约束条件 | 不能选相邻房屋 | 不能选相邻数字 |
| 核心思想 | DP | 统计 + DP |
| 难度提升 | - | 需要识别出是打家劫舍模型 |

---

## 💪 总结

这道题的解题关键：
1. **问题转化**：删除并获得点数 → 打家劫舍
2. **预处理**：统计每个数字的总点数
3. **模板应用**：套用打家劫舍模板

这道题体现了**问题建模能力**的重要性：看似复杂的问题，转化后就是经典模型。

**学习路径建议：**
1. 先做 [198. 打家劫舍](./198.md)，掌握基础模型
2. 再做本题，学习问题转化
3. 最后做 [213. 打家劫舍 II](./213.md)，理解环形处理
